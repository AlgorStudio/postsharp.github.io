---
layout: post
title: "Runtime Weaving"
date: 2008-12-12 09:07:47 +01:00
categories: [General]
permalink: /post/runtime-weaving.html
---
<h2>Transparent proxies, RealProxy and ContextBoundObject</h2><p>The idea here is to put a proxy between the woven class and the consumer. It uses the same mechanism as in remoting: the client 'see' the remote object, but it actually talks to its proxy. All accesses to the aspected object go through the proxy class. The aspect is implemented as a transparent proxy, derived from the <em>System.Runtime.Remoting.Proxies.RealProxy</em> class.</p><p>There are tree ways to tell that an object should be accessed to a proxy:</p><ul><li>If the aspected class is derived from <strong>ContextBoundObject</strong>, apply the <em>System.Runtime.Remoting.Proxies.ProxyAttribute</em> to this class in order to specify which proxy class should be used.</li><li>If the aspected class is derived from <strong>MarshalByRefObject</strong>, the method <em>RealProxy.GetTransparentProxy()</em> can be called in order to retrieve the proxy of an existing instance. But this means that user code cannot use constructors to get instances of aspected objects, but should use instead factory methods.</li><li>Otherwise, the aspected class should expose all its semantics on an interface.</li></ul><p>These methods have thus the disadvantages of restricting the aspectable methods to instance methods of classed derived from ContextBoundObject or MarshalByRefObject. What is more, the only possible join points are method boundaries, as with the previous approach.</p><p>Tools:</p><ul><li><span><a href="http://www.codeplex.com/entlib">Microsoft Enterprise Library</a></span> (Policy Injection Application Block)</li></ul><div id="load-time-static-weaving"><h2><a name="load-time-static-weaving" title="load-time-static-weaving"></a>Load-Time Static Weaving</h2><p>This approach is very similar to <a href="aop-net/compiletime-weaving/">Compile-Time Weaving</a>, but occurs it occurs at runtime <em>just before the assembly is loaded in memory</em>. This situation is adequate when changing the aspects can require the application to be restarted. In its pure application, it does not enable a true dynamic weaving. PostSharp fully supports this scenario.</p><p>A variant of this approach is to add join point to code using static weaving, but add advices to join points at runtime, i.e. without restarting the application. It is not difficult to realize this using PostSharp, but it is not ready as an out-of-the-box feature. The disadvantage of this variant is of course that one should choose a balance between join point density (and so flexibility) and performance. Too many join points will produce a huge and slow code.</p><p>Tools:</p><ul><li><a href="/">PostSharp</a></li><li><span><a href="http://www.dsg.cs.tcd.ie/dynamic/?category_id=194">Weave.NET</a></span></li><li><span><a href="http://rail.dei.uc.pt/">Rail</a></span></li></ul></div><div id="static-weaving-with-dynamic-advices"><h2><a name="static-weaving-with-dynamic-advices" title="static-weaving-with-dynamic-advices"></a>Static Weaving with Dynamic Advices</h2><p>The code is modified using <a href="aop-net/compiletime-weaving/">Compile-Time Weaving</a> techniques (eventually done at load-time, see above) so that 'hooks' are called at some locations. What the hooks really do can be changed at runtime.</p><p>Tools:</p><ul><li><span><a href="http://www.codeplex.com/entlib">Microsoft Enterprise Library</a></span> (Policy Injection Application Block), augmented by <a href="http://www.postsharp.org/contributions/application-frameworks/postsharp4entlib">PostSharp4EntLib</a></li><li><span><a href="http://setpoint.codehaus.org/Home">SetPoint</a></span></li></ul></div><div id="jit-emission-of-classes"><h2><a name="jit-emission-of-classes" title="jit-emission-of-classes"></a>JIT Emission of Classes</h2><p>This approach works only with public virtual methods and with interfaces. There are two approaches: the first is to generate a proxy class implementing the semantics of an interface. In this case, only interface methods can be aspected. The second approach is to generate a child class inherited from the aspected class; it requires this class to be unsealed and it is limited to virtual methods.</p><p>The <em>System.Reflection.Emit</em> namespace can be used. Besides of being limited to interface or virtual methods, this approach only supports the join points located at method boundaries (on entry, on exit, on exception).</p><p>Tools:</p><ul><li><a href="http://www.springframework.net/">Spring Framework for .NET</a></li><li><a href="http://www.castleproject.org/">Windsor Castle</a></li><li><span><a href="http://www.castleproject.org/aspectsharp/index.html">Aspect#</a></span></li><li><span><a href="http://www.puzzleframework.com/">NAspect</a></span></li><li><span><a href="http://www.dcl.hpi.uni-potsdam.de/research/loom/rapier_loom.htm">Rapier Loom</a></span></li></ul></div><div id="profiler-api"><h2><a name="profiler-api" title="profiler-api"></a>Profiler API</h2><p>The Unmanaged Profiler API of the .NET Framework is initially intended to instrument the code, typically for memory and processor consumption. The same API can be used to execute virtually any code. Since the granularity of the Profiler API is very fine, it is possible to define a large range of join points. The outcome however is that the code has to be executed besides the profiler, which is not aimed to be used in production. This makes this approach inappropriate for commercial software.</p></div><div id="debugger-api-edit-and-continue"><h2><a name="debugger-api-edit-and-continue" title="debugger-api-edit-and-continue"></a>Debugger API & Edit and Continue</h2><p>The idea here is partially similar to the use of the Profiler API, but additionally the edit-and-continue facility can be used to modify MSIL code at runtime. This has the potential to get faster code than with the Profiler API. However, it has the same disadvantages, that is, it is little appropriate for commercial software.</p><p>Tools:</p><ul><li><span><a href="http://www.columbia.edu/~me133/">Wicca</a></span></li></ul></div><p>&nbsp;</p>
