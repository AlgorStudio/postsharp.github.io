---
layout: post
title: "MSIL Injection"
date: 2008-12-12 09:04:18 +01:00
categories: [General]
permalink: /post/msil-injection.html
---
<h1>MSIL Injection</h1>
<p>MSIL Injection, or MSIL Insertion, is the process of modifying the MSIL instructions 
of an existing method. One says that we <em>inject</em>, or <em>insert</em> new 
instructions into an existing flow.</p>
<p>Injecting IL instructions is just a part of IL-level weaving. Modifying an existing 
code requires the following tasks to be done:</p>
<ol>
	<li>Reading the metadata of the .NET module.</li>
	<li>Decoding the stream of IL instructions in a meaningful way.</li>
	<li>Detecting the points where new instructions should be injected.</li>
	<li>Restructuring the method body if exception handlers have to be added.</li>
	<li>Injecting IL instructions properly speaking.</li>
	<li>Assembling back the in-memory representation to a binary file.</li>
</ol>
<p>These tasks are performed by an <strong>IL reader/writer</strong>, excepted the 
task 3 (detection of injection points), which is typically the task of the code 
weaver.</p>
<div id="how-to-inject-msil-instructions">
	<h2>
	<a name="how-to-inject-msil-instructions" title="how-to-inject-msil-instructions">
	</a>How to inject MSIL instructions?</h2>
	<p>If you are decided to inject directly MSIL instructions, prepare a stock 
	of aspirins and eventually prepare your girlfriend to being absent from home. 
	Then you may choose between the following approaches.</p>
	<div id="standard-system-reflection-system-reflection-emit-api">
		<h3>
		<a name="standard-system-reflection-system-reflection-emit-api" title="standard-system-reflection-system-reflection-emit-api">
		</a>Standard System.Reflection/System.Reflection.Emit API</h3>
		<p>Since it ships with the .NET Framework, why not to use it? Well, these 
		APIes seem adequate to create brandly new classes and methods, but are less 
		appropriate to properly <em>inject</em> instructions, that is, modify an 
		existing method. The principal problem is that the API is strictly stream 
		oriented: you have to write the whole method in a single pass. This is not 
		always feasible and is never easy.</p>
		<p>Another problem is that the <em>System.Reflection</em> API does not give 
		an exact image of a .NET module. It could cover 99% of your needs, but you 
		will <em>not</em> have the possibility to support the last percent. For 
		instance, <em>System.Reflection</em> does not make the difference between
		<em>void*</em> and <em>System.IntPtr</em> or <em>int32</em> and <em>System.Int32</em>. 
		Other advanced features like security attributes or marshaling may have 
		an incomplete support.</p>
	</div>
	<div id="mono-cecil">
		<h3><a name="mono-cecil" title="mono-cecil"></a>Mono Cecil</h3>
		<p>Mono Cecil is a valid choice if you are looking for an IL reader/writer. 
		It has a solid community and some commercial applications, which is a good 
		assurance of quality. Even if the project is related to Mono, it supports 
		also the Microsoft implementation. Read more on
		<span>
		<a href="http://www.mono-project.com/Cecil">http://www.mono-project.com/Cecil</a></span>.</p>
	</div>
	<div id="postsharp">
		<h3><a name="postsharp" title="postsharp"></a>PostSharp</h3>
		<p><a href="/">PostSharp</a> contains a IL reader/writer 
		that covers the complete .NET specification for managed code. The APIes 
		are optimized for high usability, so some users say it is easier to use 
		than Cecil. The greater difference with Cecil is that PostSharp is designed 
		as a platform where the IL reader/writer is only one component. The platform 
		takes in charge the complete post-compilation process, including the integration 
		with MSBuild, and offers a lot of additional services typically used by 
		code weavers (type hierarchy analysis, use/used by analysis, ...).</p>
	</div>
	<div id="microsoft-phoenix">
		<h3><a name="microsoft-phoenix" title="microsoft-phoenix"></a>Microsoft 
		Phoenix</h3>
		<p>Phoenix is the new framework for the next generation of compilers at 
		Microsoft. It abstracts the target machine, so it can work with MSIL assembly 
		as well as Intel x86 assembly. Some users say that the price to pay is a 
		greater complexity. The greatest advantage is of course the certainty of 
		support and continuity. But pay attention to the license, it is currently 
		reserved for academical research.</p>
	</div>
	<div id="rail">
		<h3><a name="rail" title="rail"></a>Rail</h3>
		<p>The initial aim of Rail is to implement an API that allows CLR assemblies 
		to be manipulated and instrumented before they are loaded and executed. 
		It uses static weaving of IL instructions. The APIes of Rail are often used 
		as an IL reader/writer with some more advanced weaving capabilities. More 
		on <span>
		<a href="http://rail.dei.uc.pt/">http://rail.dei.uc.pt/</a></span>.</p>
	</div>
</div>
