---
layout: post
title: "Getting Started"
date: 2008-12-03 19:46:44 +01:00
categories: [General]
permalink: /post/getting-started.html
---
<h1>Getting Started With PostSharp</h1><p>PostSharp Laos makes aspect-oriented programming easy. You can start writing your own aspect in a matter of minutes. Just follow the guide!</p><h2>1. Before your forget...</h2><p><a href="http://del.icio.us/post?title=PostSharp&url=http://www.postsharp.org/">Bookmark us with del.icio.us</a> and <a href="http://feeds.feedburner.com/postsharp">subscribe to our RSS feed</a>.</p><h2>2. Download & Install PostSharp</h2><p>Yes, you have to <a href="download">download</a> and install! But don't worry, it's only 5 MB. Execute the installer (you will need administrative rights) and restart Visual Studio.</p><h2>3. Open Your Favorite Project</h2><p>Load one of your projects into Visual Studio 2005 or higher. Any project type will work, but for this example better choose a console application. No matter if you use C#, VB.NET, or another language: it will just work. (Since ASP.NET Web Sites don't use MSBuild, it's a little more difficult with these projects; refer to documentation for details.)</p><h2>4. Add References To PostSharp</h2><p>You want to use PostSharp in your project, isn't it? So add a reference to two assemblies: <em>PostSharp.Public.dll</em> and <em>PostSharp.Laos.dll</em>.</p><p class="t-center"><img src="/assets/2008-12-03-getting_started/ps-custom-attributes-1-001.png" alt="Add References to PostSharp" width="411" height="344" /></p><h2>5. Create a New Aspect Class</h2><p>Create a class and name it <em>TraceAttribute</em>.</p><pre>public sealed class TraceAttribute : Attribute<br />{<br />    private readonly string category;<br /> <br />    public TraceAttribute( string category )<br />    {<br />        this.category = category;<br />    }<br /> <br />    public string Category { get { return category; } }<br />}</pre><h2>6. Derive the Class from OnMethodBoundary</h2><p>Includes the namespace <em>PostSharp.Laos</em> and make the new class inherit from <em>OnMethodBoundaryAspect</em>. Since this last class derives from <em>System.Attribute</em>, you are actually developing a custom attribute.</p><pre>[Serializable]<br />public sealed class TraceAttribute : OnMethodBoundaryAspect<br />{</pre><h2>7. Implement the Handlers</h2><p>Once the aspect custom attribute will be applied to a method, this method will invoke the aspect handlers. Do we want to trace methods? So just add trace logic to the handlers!</p><pre>    public override void OnEntry( MethodExecutionEventArgs eventArgs )<br />    {<br />        Trace.WriteLine(<br />            string.Format( "Entering {0}.{1}.",<br />                           eventArgs.Method.DeclaringType.Name,<br />                           eventArgs.Method.Name ),<br />            this.category );<br />    }<br /> <br />    public override void OnExit( MethodExecutionEventArgs eventArgs )<br />    {<br />        Trace.WriteLine(<br />            string.Format( "Leaving {0}.{1}.",<br />                           eventArgs.Method.DeclaringType.Name,<br />                           eventArgs.Method.Name ),<br />            this.category );<br />    }</pre><h2>8. Apply the Custom Attribute to Methods</h2><p>In your project, choose an existing class you want to log and decorate it with our new custom attributes. All methods will be traced. If you prefer to trace some of these methods, don't apply the custom attribute on the class, but on each method.</p><pre>internal static class Program<br />{<br />    private static void Main()<br />    {<br />        Trace.Listeners.Add(new TextWriterTraceListener( Console.Out));<br />       <br />        SayHello();<br />        SayGoodBye();<br />    }<br /> <br />    [Trace( "MyCategory" )]<br />    private static void SayHello()<br />    {<br />        Console.WriteLine("Hello, world." );<br />    }<br /> <br />    [Trace("MyCategory")]<br />    private static void SayGoodBye()<br />    {<br />        Console.WriteLine("Good bye, world.");<br />    }<br />}</pre><p>And what if you have a, say, very large assembly? You surely don't want to decorate every method to log, don't you? Well, no problem at all!</p><pre>[assembly: Trace( "MyCategory", AttributeTargetTypes = "My.BusinessLayer.*")] </pre><p> </p><h2>9. We're done! Compile & Execute</h2><p>That's all, really! If you have a console application, the output should include tracing information. </p><p class="t-center"><img src="/assets/2008-12-03-getting_started/ps-custom-attributes-1-002.png" alt="The output of our program with tracing." width="497" height="301" /></p><h2>10. How did it work?</h2><p>Seems magic, huh? Well, to some extent, it is. Open the Output Window of Visual Studio and look at the Build Output: you will see that PostSharp has been invoked. This is the magic wand!</p><p class="t-center"><img src="/assets/2008-12-03-getting_started/ps-custom-attributes-1-003.png" alt="Build output: PostSharp is inserted in the build process." width="525" height="164" /></p><p class="t-left">And now, inspect your assembly using .NET Reflector. You will see how PostSharp enhanced your code:</p><p class="t-center"><img src="/assets/2008-12-03-getting_started/ps-custom-attributes-1-004.png" alt="" /></p><h2>More tutorials like this</h2><p>This tutorial is a shorter version of a <a href="http://www.codeproject.com/KB/dotnet/ps-custom-attributes-1.aspx">two-parts article published on codeproject.com</a>. A good way to continue reading about PostSharp!</p>
